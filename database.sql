-- Enable PostGIS for geospatial queries
CREATE EXTENSION IF NOT EXISTS postgis;

DROP TABLE IF EXISTS "Upvotes" CASCADE;
DROP TABLE IF EXISTS "Report" CASCADE;
DROP TABLE IF EXISTS "Users" CASCADE;
DROP TABLE IF EXISTS "RouteAlternative" CASCADE;
DROP TABLE IF EXISTS "RouteSearch" CASCADE;
DROP TABLE IF EXISTS "RoutePointCache" CASCADE;

CREATE TABLE "Users" (
    user_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id_auth uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    name varchar(100) NOT NULL,
    email varchar(100) NOT NULL UNIQUE,
    points int DEFAULT 0,
    avatar_url text
);

CREATE TABLE "Report" (
    report_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id bigint NOT NULL REFERENCES "Users" (user_id),
    description text,
    photo_url text,
    latitude float NOT NULL,
    longitude float NOT NULL,
    category varchar(255) NOT NULL,
    address text,
    upvote_count int DEFAULT 0,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    -- New column for efficient geospatial indexing
    location geography(Point, 4326)
);

-- Create a geospatial index for fast nearby searches
CREATE INDEX report_location_idx ON "Report" USING GIST (location);

-- Function and Trigger to auto-populate the 'location' column
CREATE OR REPLACE FUNCTION update_report_location()
RETURNS TRIGGER AS $$
BEGIN
    NEW.location = ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326)::geography;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER report_location_trigger
BEFORE INSERT OR UPDATE ON "Report"
FOR EACH ROW EXECUTE FUNCTION update_report_location();


CREATE TABLE "Upvotes" (
    upvote_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id bigint NOT NULL REFERENCES "Users"(user_id) ON DELETE CASCADE,
    report_id bigint NOT NULL REFERENCES "Report"(report_id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT unique_user_report_upvote UNIQUE (user_id, report_id)
);

CREATE TABLE "RouteSearch" (
    search_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    job_id uuid NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    start_point varchar(255) NOT NULL,
    end_point varchar(255) NOT NULL,
    mode varchar(50) NOT NULL,
    status text DEFAULT 'pending', 
    results jsonb, 
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE "RoutePointCache" (
    point_cache_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    latitude float NOT NULL,
    longitude float NOT NULL,
    walkability_score float,
    photo_url text,
    tree_count int,
    sidewalk_area float,
    is_residential_road boolean,
    heading int,
    detected_labels jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT routepointcache_lat_lng_unique UNIQUE (latitude, longitude)
);

CREATE TABLE "RouteAlternative" (
    route_alt_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    search_id bigint NOT NULL REFERENCES "RouteSearch" (search_id) ON DELETE CASCADE,
    average_walkability_score float NOT NULL,
    overview_polyline text NOT NULL,
    point_ids bigint[]
);

-- Function to get reports near a specific point
CREATE OR REPLACE FUNCTION get_reports_nearby(
    p_lat float,
    p_lng float,
    p_radius_meters int DEFAULT 500 -- Default search radius of 500 meters
)
RETURNS SETOF "Report" AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM "Report"
    WHERE ST_DWithin(
        location,
        ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography,
        p_radius_meters
    );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
INSERT INTO public."Users" (user_id_auth, name, email, avatar_url)
VALUES (
new.id,
new.raw_user_meta_data->>'full_name',
new.email,
new.raw_user_meta_data->>'avatar_url'
);
RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

CREATE OR REPLACE FUNCTION public.create_report_atomic(
    p_user_id_auth uuid,
    p_category varchar,
    p_description text,
    p_latitude float,
    p_longitude float,
    p_photo_url text,
    p_address text
)
RETURNS json AS $$
DECLARE
v_internal_user_id bigint;
v_new_report public."Report";
BEGIN

SELECT user_id INTO v_internal_user_id FROM public."Users" WHERE user_id_auth = p_user_id_auth;
IF v_internal_user_id IS NULL THEN
RAISE EXCEPTION 'User not found for auth id %', p_user_id_auth;
END IF;

INSERT INTO public."Report" (user_id, category, description, latitude, longitude, photo_url, address)
VALUES (v_internal_user_id, p_category, p_description, p_latitude, p_longitude, p_photo_url, p_address)
RETURNING * INTO v_new_report;

UPDATE public."Users"
SET points = points + 10
WHERE user_id = v_internal_user_id;

RETURN row_to_json(v_new_report);

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.upvote_report_atomic(p_report_id bigint, p_user_id_auth uuid)
RETURNS json AS $$
DECLARE
v_internal_user_id bigint;
v_owner_user_id bigint;
v_new_upvote_count int;
BEGIN

SELECT user_id INTO v_internal_user_id FROM public."Users" WHERE user_id_auth = p_user_id_auth;
IF v_internal_user_id IS NULL THEN
RAISE EXCEPTION 'Upvoter not found';
END IF;

SELECT user_id INTO v_owner_user_id FROM public."Report" WHERE report_id = p_report_id;
IF v_owner_user_id IS NULL THEN
    RAISE EXCEPTION 'Report not found';
END IF;

IF v_internal_user_id = v_owner_user_id THEN
    RAISE EXCEPTION 'User cannot upvote their own report';
END IF;

INSERT INTO public."Upvotes" (report_id, user_id) VALUES (p_report_id, v_internal_user_id);

UPDATE public."Report"
SET upvote_count = upvote_count + 1
WHERE report_id = p_report_id
RETURNING upvote_count INTO v_new_upvote_count;

UPDATE public."Users"
SET points = points + 5
WHERE user_id = v_owner_user_id;

RETURN json_build_object('status', 'success', 'new_upvote_count', v_new_upvote_count);

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE POLICY "Allow authenticated uploads"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
bucket_id = 'avatars' AND
auth.uid() = (storage.foldername(name))[1]::uuid
);

CREATE POLICY "Allow authenticated read access"
ON storage.objects FOR SELECT
TO authenticated
USING (
bucket_id = 'avatars'
);

CREATE POLICY "Allow authenticated updates"
ON storage.objects FOR UPDATE
TO authenticated
USING (
bucket_id = 'avatars' AND
auth.uid() = owner
);

CREATE POLICY "Allow authenticated deletes"
ON storage.objects FOR DELETE
TO authenticated
USING (
bucket_id = 'avatars' AND
auth.uid() = owner
);

CREATE POLICY "Allow authenticated report photo uploads"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'report-photos' );

CREATE POLICY "Allow public read access on report photos"
ON storage.objects FOR SELECT
USING ( bucket_id = 'report-photos' );

CREATE INDEX idx_users_user_id_auth ON "Users"(user_id_auth);
CREATE INDEX idx_report_user_id ON "Report"(user_id);
CREATE INDEX idx_upvotes_report_id ON "Upvotes"(report_id);

-- Policies for the Users table
ALTER TABLE "Users" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow individual read access"
ON public."Users" FOR SELECT
USING (auth.uid() = user_id_auth);

CREATE POLICY "Allow individual update access"
ON public."Users" FOR UPDATE
USING (auth.uid() = user_id_auth);

-- Policies for the Report table
ALTER TABLE "Report" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all authenticated users to read reports"
ON public."Report" FOR SELECT
TO authenticated
USING (TRUE);

CREATE POLICY "Allow authenticated user to create a report"
ON public."Report" FOR INSERT
TO authenticated
WITH CHECK (user_id = (SELECT user_id FROM "Users" WHERE user_id_auth = auth.uid()));

CREATE POLICY "Allow creator to update/delete their own report"
ON public."Report" FOR ALL
USING (user_id = (SELECT user_id FROM "Users" WHERE user_id_auth = auth.uid()));

-- Policies for the Upvotes table
ALTER TABLE "Upvotes" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all authenticated users to read upvotes"
ON public."Upvotes" FOR SELECT
TO authenticated
USING (TRUE);

CREATE POLICY "Allow authenticated user to create upvote"
ON public."Upvotes" FOR INSERT
TO authenticated
WITH CHECK (user_id = (SELECT user_id FROM "Users" WHERE user_id_auth = auth.uid()));

-- NEW: Policies for RouteSearch and RoutePointCache to allow worker access
ALTER TABLE "RouteSearch" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "RoutePointCache" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow authenticated service to access RouteSearch"
ON public."RouteSearch" FOR ALL
TO authenticated
USING (TRUE);

CREATE POLICY "Allow authenticated service to access RoutePointCache"
ON public."RoutePointCache" FOR ALL
TO authenticated
USING (TRUE);
